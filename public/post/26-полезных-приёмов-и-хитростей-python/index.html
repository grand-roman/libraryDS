<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="author" content="">
<meta name="description" content="Python — один из самых популярных и востребованных языков программирования. На это есть несколько причин: - Его легко изучить. - Он очень универсальный. - У него есть множество модулей и библиотек. В процессе работы с Python каждый находит для себя какие-то полезные модули и приёмы. В этой подборке вы узнаете о некоторых полезных хитростях.
all и any Одна из многих причин популярности Python — его читабельность и выразительность. Часто шутят, что Python — это «исполняемый псевдокод»." />
<meta name="keywords" content="" />
<meta name="robots" content="noodp" />
<meta name="theme-color" content="#252627" />
<link rel="canonical" href="/post/26-%D0%BF%D0%BE%D0%BB%D0%B5%D0%B7%D0%BD%D1%8B%D1%85-%D0%BF%D1%80%D0%B8%D1%91%D0%BC%D0%BE%D0%B2-%D0%B8-%D1%85%D0%B8%D1%82%D1%80%D0%BE%D1%81%D1%82%D0%B5%D0%B9-python/" />


    <title>
        
            26 полезных приёмов и хитростей Python :: Library Data Science 
        
    </title>



<link href="https://cdnjs.cloudflare.com/ajax/libs/flag-icon-css/3.2.1/css/flag-icon.min.css" rel="stylesheet"
    type="text/css">



<link rel="stylesheet" href="/main.min.84ed5579024525d4b50458514d1a43e40dd5272df45c7cd6da85b225af457154.css">




    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#252627">
    <link rel="shortcut icon" href="/favicon.ico">
    <meta name="msapplication-TileColor" content="#252627">
    <meta name="theme-color" content="#252627">

<meta itemprop="name" content="26 полезных приёмов и хитростей Python">
<meta itemprop="description" content="Python — один из самых популярных и востребованных языков программирования. На это есть несколько причин: - Его легко изучить. - Он очень универсальный. - У него есть множество модулей и библиотек. В процессе работы с Python каждый находит для себя какие-то полезные модули и приёмы. В этой подборке вы узнаете о некоторых полезных хитростях.
all и any Одна из многих причин популярности Python — его читабельность и выразительность. Часто шутят, что Python — это «исполняемый псевдокод».">
<meta itemprop="datePublished" content="2020-03-25T00:00:00&#43;00:00" />
<meta itemprop="dateModified" content="2020-03-25T00:00:00&#43;00:00" />
<meta itemprop="wordCount" content="1933">



<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="26 полезных приёмов и хитростей Python"/>
<meta name="twitter:description" content="Python — один из самых популярных и востребованных языков программирования. На это есть несколько причин: - Его легко изучить. - Он очень универсальный. - У него есть множество модулей и библиотек. В процессе работы с Python каждый находит для себя какие-то полезные модули и приёмы. В этой подборке вы узнаете о некоторых полезных хитростях.
all и any Одна из многих причин популярности Python — его читабельность и выразительность. Часто шутят, что Python — это «исполняемый псевдокод»."/>



    <meta property="article:section" content="python" />



    <meta property="article:published_time" content="2020-03-25 00:00:00 &#43;0000 UTC" />








    </head>

    <body class="dark-theme">
        <div class="container">
            <header class="header">
    <span class="header__inner">
        <a href="/" style="text-decoration: none;">
    <div class="logo">
        
            <span class="logo__mark">></span>
            <span class="logo__text">$ cd /home/</span>
            <span class="logo__cursor" style=
                  "
                   
                   ">
            </span>
        
    </div>
</a>


        <span class="header__right">
            
                <nav class="menu">
    <ul class="menu__inner"><li><a href="/about/">About</a></li><li><a href="/post/">Post</a></li>
    </ul>
</nav>

                <span class="menu-trigger">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                        <path d="M0 0h24v24H0z" fill="none"/>
                        <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
                    </svg>
                </span>
            

            <span class="theme-toggle unselectable"><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M22 41C32.4934 41 41 32.4934 41 22C41 11.5066 32.4934 3 22
  3C11.5066 3 3 11.5066 3 22C3 32.4934 11.5066 41 22 41ZM7 22C7
  13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22Z"/>
</svg>
</span>
        </span>
    </span>
</header>


            <div class="content">
                
    <main class="post">

        <div class="post-info">
            
            </p>
        </div>

        <article>
            <h2 class="post-title"><a href="/post/26-%D0%BF%D0%BE%D0%BB%D0%B5%D0%B7%D0%BD%D1%8B%D1%85-%D0%BF%D1%80%D0%B8%D1%91%D0%BC%D0%BE%D0%B2-%D0%B8-%D1%85%D0%B8%D1%82%D1%80%D0%BE%D1%81%D1%82%D0%B5%D0%B9-python/">26 полезных приёмов и хитростей Python</a></h2>

            

            <div class="post-content">
                


<p>Python — один из самых популярных и востребованных языков программирования. На это есть несколько причин:
- Его легко изучить.
- Он очень универсальный.
- У него есть множество модулей и библиотек.
В процессе работы с Python каждый находит для себя какие-то полезные модули и приёмы. В этой подборке вы узнаете о некоторых полезных хитростях.</p>
<div id="all-и-any" class="section level2">
<h2>all и any</h2>
<p>Одна из многих причин популярности Python — его читабельность и выразительность.
Часто шутят, что Python — это «исполняемый псевдокод». Однако когда вы можете писать код таким образом, становится сложно не согласиться:</p>
<pre class="python"><code>x = [True, True, False]
if any(x):
    print(&quot;Как минимум один True&quot;)</code></pre>
<pre><code>## Как минимум один True</code></pre>
<pre class="python"><code>if all(x):
    print(&quot;Ни одного False&quot;)

if any(x) and not all(x):
    print(&quot;Как минимум один True и один False&quot;)</code></pre>
<pre><code>## Как минимум один True и один False</code></pre>
</div>
<div id="bashplotlib" class="section level2">
<h2>bashplotlib</h2>
<p>Хотите строить графики в консоли?</p>
<pre><code>$ pip install bashplotlib</code></pre>
<p>Стройте на здоровье.</p>
</div>
<div id="collections" class="section level2">
<h2>collections</h2>
<p>В Python есть классные встроенные типы данных, но порой они ведут себя не совсем так, как хотелось бы.
К счастью, во встроенной библиотеке Python есть модуль collections с удобными дополнительными типами данных:</p>
<pre class="python"><code>from collections import OrderedDict, Counter

# Запоминает порядок добавления ключей
x = OrderedDict(a=1, b=2, c=3)

# Считает частоту каждого символа
y = Counter(&quot;Hello World!&quot;)</code></pre>
</div>
<div id="dir" class="section level2">
<h2>dir</h2>
<p>Когда-нибудь задумывались о том, как заглянуть внутрь объекта в Python и посмотреть на его атрибуты? Конечно, задумывались.
Используем командную строку:</p>
<pre><code>&gt;&gt;&gt; dir()
&gt;&gt;&gt; dir(&quot;Hello World&quot;)
&gt;&gt;&gt; dir(dir)</code></pre>
<p>Это может пригодиться при интерактивной сессии в Python, а также для динамического изучения объектов и модулей, с которыми вы работаете.
Больше можно узнать в официальной документации.</p>
</div>
<div id="emoji" class="section level2">
<h2>emoji</h2>
<p>Да, серьёзно.</p>
<pre><code>$ pip install emoji</code></pre>
<p>И не делайте вид, что не хотите попробовать:</p>
<pre><code>from emoji import emojize

print(emojize(&quot;👍&quot;))
👍</code></pre>
</div>
<div id="from-future-import" class="section level2">
<h2>from <strong>future</strong> import</h2>
<p>Одним из последствий популярности Python является то, что постоянно разрабатываются и выходят новые версии. Новые версии — новые возможности, но только не для вас, если вы пользуетесь устаревшей.
Впрочем, не всё так плохо. Модуль <strong><strong>future</strong></strong> даёт возможность импортировать функциональность будущих версий Python. Это прямо как путешествие во времени, или магия:</p>
<pre><code>from __future__ import print_function

print(&quot;Hello World!&quot;)</code></pre>
<p>Почему бы не попробовать импортировать фигурные скобки?</p>
</div>
<div id="geopy" class="section level2">
<h2>geopy</h2>
<p>Программистам может быть сложно ориентироваться в географии. Однако модуль geopyвсё упрощает:</p>
<pre><code>$ pip install geopy</code></pre>
<p>Он работает путём абстрагирования API разных сервисов геокодирования. Этот модуль даёт возможность узнать полный адрес места, его долготу и широту и даже высоту.
Также в нём есть полезный класс Distance. Он высчитывает расстояние между двумя местами в удобной единице измерения.</p>
<pre><code>from geopy import GoogleV3

place = &quot;221b Baker Street, London&quot;
location = GoogleV3().geocode(place)

print(location.address)
print(location.location)</code></pre>
</div>
<div id="howdoi" class="section level2">
<h2>howdoi</h2>
<p>Зависли над какой-то проблемой и не можете вспомнить её решение? Нужно зайти на StackOverflow, но не хочется покидать терминал?
Тогда вам не обойтись без этого инструмента командной строки:</p>
<pre><code>$ pip install howdoi
Задайте любой вопрос, и он постарается найти ответ на него:
$ howdoi vertical align css
$ howdoi for loop in java
$ howdoi undo commits in git
$ howdoi vertical align css</code></pre>
<p>Но будьте осторожны: он извлекает код из топовых ответов на StackOverflow и не всегда даёт полезную информацию:</p>
<pre><code>$ howdoi exit vim</code></pre>
</div>
<div id="inspect" class="section level2">
<h2>inspect</h2>
<p>Модуль inspect пригодится для понимания того, что происходит за кулисами в Python. Вы даже можете вызывать его методы на них самих!
Ниже используется метод inspect.getsource() для вывода его собственного исходного кода. Также используется метод inspect.getmodule() для вывода модуля, в котором его определили.
Последняя команда выводит номер строки, на которой она сама находится:</p>
<pre><code>import inspect

print(inspect.getsource(inspect.getsource))
print(inspect.getmodule(inspect.getmodule))
print(inspect.currentframe().f_lineno)</code></pre>
<p>Конечно, кроме таких банальных применений этот модуль может оказаться полезным для понимания того, что делает ваш код. Также вы можете использовать его, чтобы писать самодокументированный код.</p>
</div>
<div id="jedi" class="section level2">
<h2>Jedi</h2>
<p>Библиотека Jedi предназначена для автодополнения и анализа кода. Она ускоряет процесс написания кода и делает его более продуктивным.
Если вы не разрабатываете свою IDE, то вам, наверное, будет более интересно использовать Jedi в качестве расширения редактора. К счастью, уже есть много вариантов.
Возможно, вы уже встречались с Jedi — IPython использует эту библиотеку для автодополнения.</p>
</div>
<div id="kwargs" class="section level2">
<h2>**kwargs</h2>
<p>Когда изучаешь любой язык, на пути встречается множество краеугольных камней. В случае с Python понимание таинственного синтаксиса **kwargsможно считать одним из них.
Две звёздочки впереди объекта словаря дают возможность передавать в функцию содержимое этого словаря как именованные аргументы.
Ключи словаря — это имена аргументов, а значения передаются в функцию. Вам даже не обязательно называть его kwargs:</p>
<pre><code>dictionary = {&quot;a&quot;: 1, &quot;b&quot;: 2}

def some_function(a, b):
    print(a + b)
    return

# оба варианта делают одно и то же:
some_function(**dictionary)
some_function(a=1, b=2)</code></pre>
<p>Это полезно в тех случаях, когда ваши функции должны обрабатывать именованные аргументы, не определённые заранее.
Прим.перев. Также это может пригодиться при написании функций-обёрток, которые передают все аргументы другой функции.</p>
</div>
<div id="генераторы-списков" class="section level2">
<h2>Генераторы списков</h2>
<p>Ещё одна классная особенность Python, дающая возможность быстро создавать списки. Такие выражения позволяют легко писать чистый код, который читается почти как естественный язык:</p>
<pre class="python"><code>numbers = [1, 2, 3, 4, 5, 6, 7]
evens = [x for x in numbers if x % 2 == 0]
odds = [y for y in numbers if y not in evens]

cities = [&#39;Лондон&#39;, &#39;Москва&#39;, &#39;Берлин&#39;]

def visit(city):
    print(&quot;Добро пожаловать в&quot;, city)

for city in cities:
    visit(city)</code></pre>
<pre><code>## Добро пожаловать в Лондон
## Добро пожаловать в Москва
## Добро пожаловать в Берлин</code></pre>
</div>
<div id="map" class="section level2">
<h2>map</h2>
<p>У Python есть хорошая встроенная поддержка функционального программирования. Одной из самых полезных возможностей является функция map(), особенно в сочетании с лямбда-функциями:</p>
<pre class="python"><code>x = [1, 2, 3]
y = map(lambda x: x + 1 , x)

# выводит [2, 3, 4]
print(list(y))</code></pre>
<pre><code>## [2, 3, 4]</code></pre>
<p>Здесь map() применяет простую лямбда-функцию на каждом элементе x и возвращает объект map, который можно преобразовать в какой-нибудь итерируемый объект вроде списка или кортежа.</p>
</div>
<div id="newspaper3k" class="section level2">
<h2>newspaper3k</h2>
<p>Если вы ещё с ним не встречались, то приготовьтесь к тому, что модуль newspaperснесёт вам крышу.
Он даёт возможность извлекать статьи и связанные мета-данные из множества разных источников. Можно извлечь изображения, текст и имена авторов.
В нём даже есть встроенная NLP-функциональность.
Поэтому, если вы собирались использовать BeautifulSoup или другую библиотеку для вебскрапинга в своём следующем проекте, лучше сэкономьте своё время и силы и установите newspaper:</p>
<pre><code>$ pip install newspaper3k</code></pre>
</div>
<div id="перегрузка-операторов" class="section level2">
<h2>Перегрузка операторов</h2>
<p>В Python есть поддержка перегрузки операторов — одной из тех штук, о которых говорят все настоящие computer-scientis’ы.
На самом деле идея проста. Когда-нибудь задумывались, почему Python позволяет использовать оператор + как для сложения чисел, так и для конкатенации строк? За этим как раз и стоит перегрузка операторов.
Вы можете определять объекты, которые используют стандартные символы операторов любым образом. Это позволяет применять их в контексте объектов, с которыми вы работаете:</p>
<pre><code>class Thing:
    def __init__(self, value):
        self.__value = value

    # Переопределяем оператор &gt;
    def __gt__(self, other):
        return self.__value &gt; other.__value

    # Переопределяем оператор &lt;
    def __lt__(self, other):
        return self.__value &lt; other.__value

something = Thing(100)
nothing = Thing(0)

# True
something &gt; nothing

# False
something &lt; nothing

# Error
something + nothing</code></pre>
</div>
<div id="pprint" class="section level2">
<h2>pprint</h2>
<p>Стандартная функция Python print() делает своё дело. Но если попытаться вывести какой-нибудь большой вложенный объект, результат будет выглядеть не очень приятно.
Здесь на помощь приходит модуль из стандартной библиотеки pprint (pretty print). С его помощью можно выводить объекты со сложной структурой в читабельном виде.
Мастхэв для любого Python-разработчика, работающего с нестандартными структурами данных:</p>
<pre><code>import requests
import pprint

url = &#39;https://randomuser.me/api/?results=1&#39;
users = requests.get(url).json()

pprint.pprint(users)</code></pre>
</div>
<div id="queue" class="section level2">
<h2>Queue</h2>
<p>Python поддерживает многопоточность, в использовании которой помогает стандартный модуль Queue.
Он позволяет реализовывать такую структуру данных, как очередь. Очереди позволяют добавлять и извлекать элементы согласно определённому правилу.
Очереди «первым пришёл — первым ушёл» («first in, first out», FIFO) позволяют извлекать объекты в порядке их добавления. Из очередей «последним пришёл — первым ушёл» («last in, first out», LIFO) можно извлекать последние добавленные объекты.
Наконец, приоритетные очереди позволяют извлекать объекты согласно порядку их сортировки.
Здесь можно посмотреть на пример использования очередей в многопоточном программировании на Python.</p>
</div>
<div id="repr" class="section level2">
<h2><strong>repr</strong></h2>
<p>При определении класса или объекта полезно добавлять «официальный» способ представления объекта строкой. Например:</p>
<pre><code>&gt;&gt;&gt; file = open(&#39;file.txt&#39;, &#39;r&#39;)
&gt;&gt;&gt; print(file)
&lt;open file &#39;file.txt&#39;, mode &#39;r&#39; at 0x10d30aaf0&gt;
Это сильно упрощает отладку. Вот всё, что вам нужно сделать:
class SomeClass:
    def __repr__(self):
        return &quot;&lt;какое-то описание&gt;&quot;

some_instance = SomeClass()

# выводит &lt;какое-то описание&gt;
print(some_instance)</code></pre>
<p>Прим.перев. Метод <strong>repr</strong>() позволяет определять строковое представление, предназначенное для программиста и удобное при использовании во время отладки, а метод <strong>str</strong>() позволяет определять понятное пользователю строковое представление, которое можно отображать в интерфейсе программы.</p>
</div>
<div id="sh" class="section level2">
<h2>sh</h2>
<p>Python — отличный скриптовый язык. Но иногда стандартные библиотеки os и subprocess вызывают только головную боль.
Библиотека sh может стать приятной альтернативой.
Она позволяет вызывать любую программу как обычную функцию, что полезно для автоматизации различных задач исключительно с помощью Python:</p>
<pre><code>import sh

sh.pwd()
sh.mkdir(&#39;new_folder&#39;)
sh.touch(&#39;new_file.txt&#39;)
sh.whoami()
sh.echo(&#39;This is great!&#39;)</code></pre>
<p><strong>Прим.перев.</strong> Библиотека sh поддерживает только платформы Linux и macOS; для работы на Windows вам придётся поискать другой инструмент.</p>
</div>
<div id="аннотации-типов" class="section level2">
<h2>Аннотации типов</h2>
<p>Python — динамически типизированный язык. Вам не нужно указывать тип данных при определении переменных, функций, классов и т.д.
Это позволяет ускорить процесс разработки. Однако мало что раздражает так сильно, как ошибка времени выполнения, возникшая из-за простого несовпадения типа.
С версии Python 3.5 при определении функции можно добавлять аннотации типов:</p>
<pre><code>def add_two(x: Int) -&gt; Int:
    return x + 2</code></pre>
<p>Можно даже определять псевдонимы типов:</p>
<pre><code>from typing import List

Vector = List[float]
Matrix = List[Vector]

def add_matrix(a: Matrix, b: Matrix) -&gt; Matrix:
    result = []
    for i, row in enumerate(a):
        result_row = []
        for j, col in enumerate(row):
            result_row += [a[i][j] + b[i][j]]
        result += [result_row]
    return result

x = [[1.0, 0.0], [0.0, 1.0]]
y = [[2.0, 1.0], [0.0, -2.0]]
z = add_matrix(x, y)</code></pre>
<p>Хотя их использование опционально, с помощью аннотаций типов код можно сделать более понятным.
Также они позволяют использовать инструменты для проверки типов, чтобы отлавливать ошибки TypeError.</p>
</div>
<div id="uuid" class="section level2">
<h2>uuid</h2>
<p>Стандартный модуль uuid — быстрый и простой способ сгенерировать UUID (universally unique identifier, глобально уникальный идентификатор).</p>
<pre><code>import uuid

user_id = uuid.uuid4()
print(user_id)</code></pre>
<p>Так мы создаём случайное 128-битное число, которое почти наверняка будет уникальным.
Существует более 2¹²² возможных UUID. Это более 5 ундециллионов или 5,000,000,000,000,000,000,000,000,000,000,000,000.
Вероятность нахождения дубликатов в заданном наборе крайне мала. Даже при наличии триллиона UUID вероятность того, что среди них есть дубликат, гораздо меньше, чем один к миллиарду.
Вполне недурно для двух строк кода.</p>
</div>
<div id="виртуальные-среды" class="section level2">
<h2>Виртуальные среды</h2>
<p>Часто Python-программисты работают над несколькими проектами одновременно. К сожалению, порой два проекта зависят от разных версий одной зависимости. Какую же установить?
К счастью, в Python есть поддержка виртуальных сред, которые позволяют взять лучшее от двух миров. В командной строке нужно ввести:</p>
<pre><code>$ python3 -m venv my-project
$ source my-project/bin/activate
$ pip install all-the-modules </code></pre>
<p>Теперь вы можете иметь разные независимые версии Python на одной машине.</p>
</div>
<div id="wikipedia" class="section level2">
<h2>wikipedia</h2>
<p>У Wikipedia есть классное API, которое позволяет получить доступ к непревзойдённому источнику полностью бесплатной информации.
Модуль wikipedia делает доступ к этому API чуть ли чрезмерно удобным:</p>
<pre><code>import wikipedia

result = wikipedia.page(&#39;freeCodeCamp&#39;)
print(result.summary)
for link in result.links:
    print(link)</code></pre>
<p>Как и настоящий сайт, модуль предоставляет поддержку многих языков, разрешение многозначности страниц, получение случайной страницы и даже метод donate().</p>
</div>
<div id="xkcd" class="section level2">
<h2>xkcd</h2>
<p>Юмор — ключевая особенность Python. В конце концов, язык был назван в честь британского комедийного шоу «Летающий цирк Монти Пайтона». Во многих местах официальной документации можно найти отсылки к самым известным эпизодам шоу.
Конечно, чувство юмора не заканчивается на документации. Попробуйте ввести следующую строку:</p>
<pre><code>import antigravity</code></pre>
<p>Оставайся собой, Python. Оставайся собой.</p>
</div>
<div id="yaml" class="section level2">
<h2>YAML</h2>
<p>YAML означает «YAML — не язык разметки» («YAML Ain’t Markup Language»). Это язык форматирования данных, являющийся надмножеством JSON.
В отличие от JSON, YAML может хранить более сложные объекты и ссылаться на собственные элементы. Также там можно писать комментарии, что делает YAML подходящим для конфигурационных файлов.
Модуль PyYAML позволяет использовать YAML в Python. Установить можно так:</p>
<pre><code>$ pip install pyyaml</code></pre>
<p>А затем импортировать:</p>
<pre><code>import yaml</code></pre>
<p>PyYAML позволяет хранить любые Python-объекты и экземпляры любых пользовательских классов.</p>
</div>
<div id="zip" class="section level2">
<h2>zip</h2>
<p>Напоследок ещё одна клёвая штука. Когда-нибудь возникала необходимость создать словарь из двух списков?</p>
<pre class="python"><code>keys = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]
vals = [1, 2, 3]
zipped = dict(zip(keys, vals))</code></pre>
<p>Встроенная функция zip() принимает несколько итерируемых объектов и возвращает последовательность кортежей. Каждый кортеж группирует элементы объектов по их индексу.
Можно провести операцию, обратную zip(), с помощью zip(*).</p>
</div>

            </div>
        </article>

        <hr />

        <div class="post-info">
  		</div>
    </main>

            </div>

            
                <footer class="footer">
    <div class="footer__inner">
        <div class="footer__content">
            <span>&copy; 2020</span>
            
            <span></span>
            <span> <a href="/posts/index.xml" target="_blank" title="rss"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></a></span>
        </div>
    </div>
    <div class="footer__inner">
        <div class="footer__content">
            <span>Powered by <a href="http://gohugo.io">Hugo</a></span>
            <span>Made with &#10084; by <a href="https://github.com/rhazdon">Djordje Atlialp</a></span>
        </div>
    </div>
</footer>

            
        </div>

        




<script type="text/javascript" src="/bundle.min.2d5469329143160ae2456a69c3c76dc2d0a3b212b46afe291a51bd68650ed6f8697e001dab54f1c272c77ce08092a8c55e5bb4314e0ee334aab4b927ec896638.js" integrity="sha512-LVRpMpFDFgriRWppw8dtwtCjshK0av4pGlG9aGUO1vhpfgAdq1TxwnLHfOCAkqjFXlu0MU4O4zSqtLkn7IlmOA=="></script>



    </body>
</html>
