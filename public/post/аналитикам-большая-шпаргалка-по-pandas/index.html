<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="author" content="Алексей Куличевский">
<meta name="description" content="Что такое Pandas и зачем он нужен Pandas — это библиотека для работы с данными на Python. Она упрощает жизнь аналитикам: где раньше использовалось 10 строк кода теперь хватит одной.
Например, чтобы прочитать данные из csv, в стандартном Python надо сначала решить, как хранить данные, затем открыть файл, прочитать его построчно, отделить значения друг от друга и очистить данные от специальных символов.
&amp;gt; with open(&amp;#39;file.csv&amp;#39;) as f: ... content = f." />
<meta name="keywords" content=", pandas" />
<meta name="robots" content="noodp" />
<meta name="theme-color" content="#252627" />
<link rel="canonical" href="/post/%D0%B0%D0%BD%D0%B0%D0%BB%D0%B8%D1%82%D0%B8%D0%BA%D0%B0%D0%BC-%D0%B1%D0%BE%D0%BB%D1%8C%D1%88%D0%B0%D1%8F-%D1%88%D0%BF%D0%B0%D1%80%D0%B3%D0%B0%D0%BB%D0%BA%D0%B0-%D0%BF%D0%BE-pandas/" />


    <title>
        
            Аналитикам: большая шпаргалка по Pandas :: Library Data Science 
        
    </title>



<link href="https://cdnjs.cloudflare.com/ajax/libs/flag-icon-css/3.2.1/css/flag-icon.min.css" rel="stylesheet"
    type="text/css">



<link rel="stylesheet" href="/main.min.84ed5579024525d4b50458514d1a43e40dd5272df45c7cd6da85b225af457154.css">




    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#252627">
    <link rel="shortcut icon" href="/favicon.ico">
    <meta name="msapplication-TileColor" content="#252627">
    <meta name="theme-color" content="#252627">

<meta itemprop="name" content="Аналитикам: большая шпаргалка по Pandas">
<meta itemprop="description" content="Что такое Pandas и зачем он нужен Pandas — это библиотека для работы с данными на Python. Она упрощает жизнь аналитикам: где раньше использовалось 10 строк кода теперь хватит одной.
Например, чтобы прочитать данные из csv, в стандартном Python надо сначала решить, как хранить данные, затем открыть файл, прочитать его построчно, отделить значения друг от друга и очистить данные от специальных символов.
&gt; with open(&#39;file.csv&#39;) as f: ... content = f.">
<meta itemprop="datePublished" content="2020-03-25T00:00:00&#43;00:00" />
<meta itemprop="dateModified" content="2020-03-25T00:00:00&#43;00:00" />
<meta itemprop="wordCount" content="2707">



<meta itemprop="keywords" content="pandas," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Аналитикам: большая шпаргалка по Pandas"/>
<meta name="twitter:description" content="Что такое Pandas и зачем он нужен Pandas — это библиотека для работы с данными на Python. Она упрощает жизнь аналитикам: где раньше использовалось 10 строк кода теперь хватит одной.
Например, чтобы прочитать данные из csv, в стандартном Python надо сначала решить, как хранить данные, затем открыть файл, прочитать его построчно, отделить значения друг от друга и очистить данные от специальных символов.
&gt; with open(&#39;file.csv&#39;) as f: ... content = f."/>



    <meta property="article:section" content="python" />



    <meta property="article:published_time" content="2020-03-25 00:00:00 &#43;0000 UTC" />








    </head>

    <body class="dark-theme">
        <div class="container">
            <header class="header">
    <span class="header__inner">
        <a href="/" style="text-decoration: none;">
    <div class="logo">
        
            <span class="logo__mark">></span>
            <span class="logo__text">$ cd /home/</span>
            <span class="logo__cursor" style=
                  "
                   
                   ">
            </span>
        
    </div>
</a>


        <span class="header__right">
            
                <nav class="menu">
    <ul class="menu__inner"><li><a href="/about/">About</a></li><li><a href="/post/">Post</a></li>
    </ul>
</nav>

                <span class="menu-trigger">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                        <path d="M0 0h24v24H0z" fill="none"/>
                        <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
                    </svg>
                </span>
            

            <span class="theme-toggle unselectable"><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M22 41C32.4934 41 41 32.4934 41 22C41 11.5066 32.4934 3 22
  3C11.5066 3 3 11.5066 3 22C3 32.4934 11.5066 41 22 41ZM7 22C7
  13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22Z"/>
</svg>
</span>
        </span>
    </span>
</header>


            <div class="content">
                
    <main class="post">

        <div class="post-info">
            
            </p>
        </div>

        <article>
            <h2 class="post-title"><a href="/post/%D0%B0%D0%BD%D0%B0%D0%BB%D0%B8%D1%82%D0%B8%D0%BA%D0%B0%D0%BC-%D0%B1%D0%BE%D0%BB%D1%8C%D1%88%D0%B0%D1%8F-%D1%88%D0%BF%D0%B0%D1%80%D0%B3%D0%B0%D0%BB%D0%BA%D0%B0-%D0%BF%D0%BE-pandas/">Аналитикам: большая шпаргалка по Pandas</a></h2>

            

            <div class="post-content">
                


<div id="что-такое-pandas-и-зачем-он-нужен" class="section level2">
<h2>Что такое Pandas и зачем он нужен</h2>
<p>Pandas — это библиотека для работы с данными на Python. Она упрощает жизнь аналитикам: где раньше использовалось 10 строк кода теперь хватит одной.</p>
<p>Например, чтобы прочитать данные из csv, в стандартном Python надо сначала решить, как хранить данные, затем открыть файл, прочитать его построчно, отделить значения друг от друга и очистить данные от специальных символов.</p>
<pre><code>&gt; with open(&#39;file.csv&#39;) as f:
...    content = f.readlines()
...    content = [x.split(&#39;,&#39;).replace(&#39;\n&#39;,&#39;&#39;) for x in content]</code></pre>
<p>В Pandas всё проще. Во-первых, не нужно думать, как будут храниться данные — они лежат в датафрейме. Во-вторых, достаточно написать одну команду:</p>
<pre><code>&gt; data = pd.read_csv(&#39;file.csv&#39;)</code></pre>
<p>Pandas добавляет в Python новые структуры данных — серии и датафреймы. Расскажу, что это такое.</p>
</div>
<div id="структуры-данных-серии-и-датафреймы" class="section level2">
<h2>Структуры данных: серии и датафреймы</h2>
<p>Серии — одномерные массивы данных. Они очень похожи на списки, но отличаются по поведению — например, операции применяются к списку целиком, а в сериях — поэлементно.</p>
<p>То есть, если список умножить на 2, получите тот же список, повторенный 2 раза.</p>
<pre class="python"><code>vector = [1, 2, 3]
vector * 2</code></pre>
<pre><code>## [1, 2, 3, 1, 2, 3]</code></pre>
<p>А если умножить серию, ее длина не изменится, а вот элементы удвоятся.</p>
<pre class="python"><code>import pandas as pd
series = pd.Series([1, 2, 3])
series * 2</code></pre>
<pre><code>## 0    2
## 1    4
## 2    6
## dtype: int64</code></pre>
<p>Обратите внимание на первый столбик вывода. Это индекс, в котором хранятся адреса каждого элемента серии. Каждый элемент потом можно получать, обратившись по нужному адресу.</p>
<pre class="python"><code>series = pd.Series([&#39;foo&#39;, &#39;bar&#39;])
series[0]</code></pre>
<pre><code>## &#39;foo&#39;</code></pre>
<p>Еще одно отличие серий от списков — в качестве индексов можно использовать произвольные значения, это делает данные нагляднее. Представим, что мы анализируем помесячные продажи. Используем в качестве индексов названия месяцев, значениями будет выручка:</p>
<pre class="python"><code>months = [&#39;jan&#39;, &#39;feb&#39;, &#39;mar&#39;, &#39;apr&#39;]
sales = [100, 200, 300, 400]
data = pd.Series(data=sales, index=months)
data</code></pre>
<pre><code>## jan    100
## feb    200
## mar    300
## apr    400
## dtype: int64</code></pre>
<p>Теперь можем получать значения каждого месяца:</p>
<pre class="python"><code>data[&#39;feb&#39;]</code></pre>
<pre><code>## 200</code></pre>
<p>Так как серии — одномерный массив данных, в них удобно хранить измерения по одному. На практике удобнее группировать данные вместе. Например, если мы анализируем помесячные продажи, полезно видеть не только выручку, но и количество проданных товаров, количество новых клиентов и средний чек. Для этого отлично подходят датафреймы.
Датафреймы — это таблицы. У их есть строки, колонки и ячейки.
Технически, колонки датафреймов — это серии. Поскольку в колонках обычно описывают одни и те же объекты, то все колонки делят один и тот же индекс:</p>
<pre class="python"><code>months = [&#39;jan&#39;, &#39;feb&#39;, &#39;mar&#39;, &#39;apr&#39;]
sales = {
  &#39;revenue&#39;:     [100, 200, 300, 400],
  &#39;items_sold&#39;:  [23, 43, 55, 65],
  &#39;new_clients&#39;: [10, 20, 30, 40]
  }
sales_df = pd.DataFrame(data=sales, index=months)
sales_df</code></pre>
<pre><code>##      revenue  items_sold  new_clients
## jan      100          23           10
## feb      200          43           20
## mar      300          55           30
## apr      400          65           40</code></pre>
<p>Объясню, как создавать датафреймы и загружать в них данные.
## Создаем датафреймы и загружаем данные
Бывает, что мы не знаем, что собой представляют данные, и не можем задать структуру заранее. Тогда удобно создать пустой датафрейм и позже наполнить его данными.</p>
<pre><code>&gt; df = pd.DataFrame()</code></pre>
<p>А иногда данные уже есть, но хранятся в переменной из стандартного Python, например, в словаре. Чтобы получить датафрейм, эту переменную передаем в ту же команду:</p>
<pre><code>&gt; df = pd.DataFrame(data=sales, index=months))</code></pre>
<p>Случается, что в некоторых записях не хватает данных. Например, посмотрите на список goods_sold — в нём продажи, разбитые по товарным категориям. За первый месяц мы продали машины, компьютеры и программное обеспечение. Во втором машин нет, зато появились велосипеды, а в третьем снова появились машины, но велосипеды исчезли:</p>
<pre><code> goods_sold = [
  {&#39;computers&#39;: 10, &#39;cars&#39;: 1, &#39;soft&#39;: 3},
  {&#39;computers&#39;: 4, &#39;soft&#39;: 5, &#39;bicycles&#39;: 1},
  {&#39;computers&#39;: 6, &#39;cars&#39;: 2, &#39;soft&#39;: 3}
]</code></pre>
<p>Если загрузить данные в датафрейм, Pandas создаст колонки для всех товарных категорий и, где это возможно, заполнит их данными:</p>
<pre><code>pd.DataFrame(goods_sold)</code></pre>
<p>Обратите внимание, продажи велосипедов в первом и третьем месяце равны NaN — расшифровывается как Not a Number. Так Pandas помечает отсутствующие значения.
Теперь разберем, как загружать данные из файлов. Чаще всего данные хранятся в экселевских таблицах или csv-, tsv- файлах.
Экселевские таблицы читаются с помощью команды pd.read_excel(). Параметрами нужно передать адрес файла на компьютере и название листа, который нужно прочитать. Команда работает как с xls, так и с xlsx:</p>
<pre><code>&gt; pd.read_excel(&#39;file.xlsx&#39;, sheet_name=&#39;Sheet1&#39;)</code></pre>
<p>Файлы формата csv и tsv — это текстовые файлы, в которых данные отделены друг от друга запятыми или табуляцией:</p>
<pre><code># CSV
month,customers,sales
feb,10,200

# TSV
month\tcustomers\tsales
feb\t10\t200</code></pre>
<p>Оба читаются с помощью команды .read_csv(), символ табуляции передается параметром sep (от англ. separator — разделитель):</p>
<pre><code>&gt; pd.read_csv(&#39;file.csv&#39;)
&gt; pd.read_csv(&#39;file.tsv&#39;, sep=&#39;\t&#39;)</code></pre>
<p>При загрузке можно назначить столбец, который будет индексом. Представьте, что мы загружаем таблицу с заказами. У каждого заказа есть свой уникальный номер, Если назначим этот номер индексом, сможем выгружать данные командой df[order_id]. Иначе придется писать фильтр df[df[‘id’] == order_id ].
О том, как получать данные из датафреймов, я расскажу в одном из следующих разделов. Чтобы назначить колонку индексом, добавим в команду read_csv() параметр index_col, равный названию нужной колонки:</p>
<pre><code>&gt; pd.read_csv(&#39;file.csv&#39;, index_col=&#39;id&#39;)</code></pre>
<p>После загрузки данных в датафрейм, хорошо бы их исследовать — особенно, если они вам незнакомы.</p>
</div>
<div id="исследуем-загруженные-данные" class="section level2">
<h2>Исследуем загруженные данные</h2>
<p>Представим, что мы анализируем продажи американского интернет-магазина. У нас есть данные о заказах и клиентах. Загрузим файл с продажами интернет-магазина в переменную orders. Раз загружаем заказы, укажем, что колонка id пойдет в индекс:</p>
<pre><code>&gt; orders = pd.read_csv(&#39;orders.csv&#39;, index_col=&#39;id&#39;)</code></pre>
<p>Расскажу о четырех атрибутах, которые есть у любого датафрейма: .shape, .columns, .index и .dtypes.
.shape показывает, сколько в датафрейме строк и колонок. Он возвращает пару значений (n_rows, n_columns). Сначала идут строки, потом колонки.</p>
<pre><code>&gt; orders.shape
(5009, 5)</code></pre>
<p>В датафрейме 5009 строк и 5 колонок.
Окей, масштаб оценили. Теперь посмотрим, какая информация содержится в каждой колонке. С помощью .columns узнаем названия колонок:</p>
<pre><code>&gt; orders.columns
Index([&#39;order_date&#39;, &#39;ship_mode&#39;, &#39;customer_id&#39;, &#39;sales&#39;], dtype=&#39;object&#39;)</code></pre>
<p>Теперь видим, что в таблице есть дата заказа, метод доставки, номер клиента и выручка.
С помощью .dtypes узнаем типы данных, находящихся в каждой колонке и поймем, надо ли их обрабатывать. Бывает, что числа загружаются в виде текста. Если мы попробуем сложить две текстовых значения ‘1’ + ‘1’, то получим не число 2, а строку ‘11’:</p>
<pre><code>&gt; orders.dtypes
order_date      object
ship_mode       object
customer_id     object
sales          float64
dtype: object</code></pre>
<p>Тип object — это текст, float64 — это дробное число типа 3,14.
C помощью атрибута .index посмотрим, как называются строки:</p>
<pre><code>&gt; orders.index
Int64Index([100006, 100090, 100293, 100328, 100363, 100391, 100678, 100706,
            100762, 100860,
            ...
            167570, 167920, 168116, 168613, 168690, 168802, 169320, 169488,
            169502, 169551],
           dtype=&#39;int64&#39;, name=&#39;id&#39;, length=5009)</code></pre>
<p>Ожидаемо, в индексе датафрейма номера заказов: 100762, 100860 и так далее.
В колонке sales хранится стоимость каждого проданного товара. Чтобы узнать разброс значений, среднюю стоимость и медиану, используем метод .describe():</p>
<pre><code>&gt; orders.describe()
         sales
count   5009.0
mean     458.6
std      954.7
min        0.6
25%       37.6
50%      152.0
75%      512.1
max    23661.2</code></pre>
<p>Наконец, чтобы посмотреть на несколько примеров записей датафрейма, используем команды .head() и .sample(). Первая возвращает 6 записей из начала датафрейма. Вторая — 6 случайных записей:</p>
<pre><code>&gt; orders.head()
        order_date ship_mode customer_id    sales
id                                                                         
100006  2014-09-07  Standard    DK-13375  377.970
100090  2014-07-08  Standard    EB-13705  699.192
100293  2014-03-14  Standard    NF-18475   91.056
100328  2014-01-28  Standard    JC-15340    3.928
100363  2014-04-08  Standard    JM-15655   21.376</code></pre>
<p>Получив первое представление о датафреймах, теперь обсудим, как доставать из него данные.</p>
</div>
<div id="получаем-данные-из-датафреймов" class="section level2">
<h2>Получаем данные из датафреймов</h2>
<p>Данные из датафреймов можно получать по-разному: указав номера колонок и строк, использовав условные операторы или язык запросов. Расскажу подробнее о каждом способе.</p>
</div>
<div id="указываем-нужные-строки-и-колонки" class="section level2">
<h2>Указываем нужные строки и колонки</h2>
<p>Продолжаем анализировать продажи интернет-магазина, которые загрузили в предыдущем разделе. Допустим, я хочу вывести столбец sales. Для этого название столбца нужно заключить в квадратные скобки и поставить после них названия датафрейма: orders[‘sales’]:</p>
<pre><code>&gt; orders[&#39;sales&#39;]
id
100006     377.970
100090     699.192
100293      91.056
100328       3.928
100363      21.376
100391      14.620
100678     697.074
100706     129.440
...</code></pre>
<p>Обратите внимание, результат команды — новый датафрейм с таким же индексом.
Если нужно вывести несколько столбцов, в квадратные скобки нужно вставить список с их названиями: orders[[‘customer_id’, ‘sales’]]. Будьте внимательны: квадратные скобки стали двойными. Первые — от датафрейма, вторые — от списка:</p>
<pre><code>&gt; orders[[&#39;customer_id&#39;, &#39;sales&#39;]]
       customer_id     sales
id                                  
100006    DK-13375   377.970
100090    EB-13705   699.192
100293    NF-18475    91.056
100328    JC-15340     3.928
100363    JM-15655    21.376
100391    BW-11065    14.620
100363    KM-16720   697.074
100706    LE-16810   129.440
...</code></pre>
<p>Перейдем к строкам. Их можно фильтровать по индексу и по порядку. Например, мы хотим вывести только заказы 100363, 100391 и 100706, для этого есть команда .loc[]:</p>
<pre><code>&gt; show_these_orders = [&#39;100363&#39;, &#39;100363&#39;, &#39;100706&#39;]
&gt; orders.loc[show_these_orders]
        order_date ship_mode customer_id    sales
id                                                             
100363  2014-04-08  Standard    JM-15655   21.376
100363  2014-04-08  Standard    JM-15655   21.376
100706  2014-12-16    Second    LE-16810  129.440</code></pre>
<p>А в другой раз бывает нужно достать просто заказы с 1 по 3 по порядку, вне зависимости от их номеров в таблицемы. Тогда используют команду .iloc[]:</p>
<pre><code>&gt; show_these_orders = [1, 2, 3]
&gt; orders.iloc[show_these_orders]
        order_date ship_mode customer_id    sales
id                                                             
100090  2014-04-08  Standard    JM-15655   21.376
100293  2014-04-08  Standard    JM-15655   21.376
100328  2014-12-16    Second    LE-16810  129.440</code></pre>
<p>Можно фильтровать датафреймы по колонкам и столбцам одновременно:</p>
<pre><code>&gt; columns = [&#39;customer_id&#39;, &#39;sales&#39;]
&gt; rows = [&#39;100363&#39;, &#39;100363&#39;, &#39;100706&#39;]
&gt; orders.loc[rows][columns]
       customer_id    sales
id                                 
100363    JM-15655   21.376
100363    JM-15655   21.376
100706    LE-16810  129.440
...</code></pre>
<p>Часто вы не знаете заранее номеров заказов, которые вам нужны. Например, если задача — получить заказы, стоимостью более 1000 рублей. Эту задачу удобно решать с помощью условных операторов.</p>
</div>
<div id="если-то.-условные-операторы" class="section level2">
<h2>Если — то. Условные операторы</h2>
<p>Задача: нужно узнать, откуда приходят самые большие заказы. Начнем с того, что достанем все покупки стоимостью более 1000 долларов:</p>
<pre><code>&gt; filter_large = orders[&#39;sales&#39;] &gt; 1000
&gt; orders.loc[filter_slarge]
        order_date ship_mode customer_id     sales
id                                                             
101931  2014-10-28     First    TS-21370  1252.602
102673  2014-11-01  Standard    KH-16630  1044.440
102988  2014-04-05    Second    GM-14695  4251.920
103100  2014-12-20     First    AB-10105  1107.660
103310  2014-05-10  Standard    GM-14680  1769.784
...</code></pre>
<p>Помните, в начале статьи я упоминал, что в сериях все операции применяются по-элементно? Так вот, операция orders[‘sales’] &gt; 1000 идет по каждому элементу серии и, если условие выполняется, возвращает True. Если не выполняется — False. Получившуюся серию мы сохраняем в переменную filter_large.
Вторая команда фильтрует строки датафрейма с помощью серии. Если элемент filter_large равен True, заказ отобразится, если False — нет. Результат — датафрейм с заказами, стоимостью более 1000 долларов.
Интересно, сколько дорогих заказов было доставлено первым классом? Добавим в фильтр ещё одно условие:</p>
<pre><code>&gt; filter_large = df[&#39;sales&#39;] &gt; 1000
&gt; filter_first_class = orders[&#39;ship_mode&#39;] == &#39;First&#39;
&gt; orders.loc[filter_large &amp; filter_first_class]
        order_date ship_mode customer_id     sales
id                                                           
101931  2014-10-28     First    TS-21370  1252.602
103100  2014-12-20     First    AB-10105  1107.660
106726  2014-12-06     First    RS-19765  1261.330
112158  2014-12-02     First    DP-13165  1050.600
116666  2014-05-08     First    KT-16480  1799.970
...</code></pre>
<p>Логика не изменилась. В переменную filter_large сохранили серию, удовлетворяющую условию orders[‘sales’] &gt; 1000. В filter_first_class — серию, удовлетворяющую orders[‘ship_mode’] == ‘First’.
Затем объединили обе серии с помощью логического ‘И’: filter_first_class &amp; filter_first_class. Получили новую серию той же длины, в элементах которой True только у заказов, стоимостью больше 1000, доставленных первым классом. Таких условий может быть сколько угодно.</p>
</div>
<div id="язык-запросов" class="section level2">
<h2>Язык запросов</h2>
<p>Еще один способ решить предыдущую задачу — использовать язык запросов. Все условия пишем одной строкой ‘sales &gt; 1000 &amp; ship_mode == ’First’ и передаем ее в метод .query(). Запрос получается компактнее.</p>
<pre><code>&gt; orders.query(&#39;sales &gt; 1000 &amp; ship_mode == First&#39;)
        order_date ship_mode customer_id     sales
id                                                           
101931  2014-10-28     First    TS-21370  1252.602
103100  2014-12-20     First    AB-10105  1107.660
106726  2014-12-06     First    RS-19765  1261.330
112158  2014-12-02     First    DP-13165  1050.600
116666  2014-05-08     First    KT-16480  1799.970
...</code></pre>
<p>Отдельный кайф: значения для фильтров можно сохранить в переменной, а в запросе сослаться на нее с помощью символа @: sales &gt; <span class="citation">@sales_filter</span>.</p>
<pre><code>&gt; sales_filter = 1000
&gt; ship_mode_filter = &#39;First&#39;
&gt; orders.query(&#39;sales &gt; @sales_filter &amp; ship_mode &gt; @ship_mode_filter&#39;)
         order_date ship_mode customer_id     sales
id                                                           
101931  2014-10-28     First    TS-21370  1252.602
103100  2014-12-20     First    AB-10105  1107.660
106726  2014-12-06     First    RS-19765  1261.330
112158  2014-12-02     First    DP-13165  1050.600
116666  2014-05-08     First    KT-16480  1799.970
...</code></pre>
<p>Разобравшись, как получать куски данных из датафрейма, перейдем к тому, как считать агрегированные метрики: количество заказов, суммарную выручку, средний чек, конверсию.</p>
</div>
<div id="считаем-производные-метрики" class="section level2">
<h2>Считаем производные метрики</h2>
<p>Задача: посчитаем, сколько денег магазин заработал с помощью каждого класса доставки. Начнем с простого — просуммируем выручку со всех заказов. Для этого используем метод .sum():</p>
<pre><code>&gt; orders[&#39;sales&#39;].sum()
2297200.8603000003
Добавим класс доставки. Перед суммированием сгруппируем данные с помощью метода .groupby():
&gt; orders.groupby(&#39;ship_mode&#39;)[&#39;sales&#39;].sum()
ship_mode              
First      3.514284e+05
Same Day   1.283631e+05
Second     4.591936e+05
Standard   1.358216e+06</code></pre>
<p>3.514284e+05 — научный формат вывода чисел. Означает 3.51 * 105. Нам такая точность не нужна, поэтому можем сказать Pandas, чтобы округлял значения до сотых:</p>
<pre><code>&gt; pd.options.display.float_format = &#39;{:,.1f}&#39;.format
&gt; orders.groupby(&#39;ship_mode&#39;)[&#39;sales&#39;].sum()
ship_mode            
First       351,428.4
Same Day    128,363.1
Second      459,193.6
Standard  1,358,215.7</code></pre>
<p>Другое дело. Теперь видим сумму выручки по каждому классу доставки. По суммарной выручке неясно, становится лучше или хуже. Добавим разбивку по датам заказа:</p>
<pre><code>&gt; orders.groupby([&#39;ship_mode&#39;, &#39;order_date&#39;])[&#39;sales&#39;].sum()
ship_mode order_date        
First     2014-01-06    12.8
          2014-01-11     9.9
          2014-01-14    62.0
          2014-01-15   149.9
          2014-01-19   378.6
          2014-01-26   152.6
...</code></pre>
<p>Видно, что выручка прыгает ото дня ко дню: иногда 10 долларов, а иногда 378. Интересно, это меняется количество заказов или средний чек? Добавим к выборке количество заказов. Для этого вместо .sum() используем метод .agg(), в который передадим список с названиями нужных функций.</p>
<pre><code>&gt; orders.groupby([&#39;ship_mode&#39;, &#39;order_date&#39;])[&#39;sales&#39;].agg([&#39;sum&#39;, &#39;count&#39;])
                       sum  count
ship_mode order_date             
First     2014-01-06  12.8      1
          2014-01-11   9.9      1
          2014-01-14  62.0      1
          2014-01-15 149.9      1
          2014-01-19 378.6      1
          2014-01-26 152.6      1
...</code></pre>
<p>Ого, получается, что это так прыгает средний чек. Интересно, а какой был самый удачный день? Чтобы узнать, отсортируем получившийся датафрейм: выведем 10 самых денежных дней по выручке:</p>
<pre><code>&gt; orders.groupby([&#39;ship_mode&#39;, &#39;order_date&#39;])[&#39;sales&#39;].agg([&#39;sum&#39;]).sort_values(by=&#39;sum&#39;, ascending=False).head(10)
                          sum
ship_mode order_date         
Standard  2014-03-18 26,908.4
          2016-10-02 18,398.2
First     2017-03-23 14,299.1
Standard  2014-09-08 14,060.4
First     2017-10-22 13,716.5
Standard  2016-12-17 12,185.1
          2017-11-17 12,112.5
          2015-09-17 11,467.6
          2016-05-23 10,561.0
          2014-09-23 10,478.6</code></pre>
<p>Команда разрослась, и её теперь неудобно читать. Чтобы упростить, можно разбить её на несколько строк. В конце каждой строки ставим обратный слеш :</p>
<pre><code>&gt; orders \
... .groupby([&#39;ship_mode&#39;, &#39;order_date&#39;])[&#39;sales&#39;] \
... .agg([&#39;sum&#39;]) \
... .sort_values(by=&#39;sum&#39;, ascending=False) \
... .head(10)
                          sum
ship_mode order_date         
Standard  2014-03-18 26,908.4
          2016-10-02 18,398.2
First     2017-03-23 14,299.1
Standard  2014-09-08 14,060.4
First     2017-10-22 13,716.5
Standard  2016-12-17 12,185.1
          2017-11-17 12,112.5
          2015-09-17 11,467.6
          2016-05-23 10,561.0
          2014-09-23 10,478.6</code></pre>
<p>В самый удачный день — 18 марта 2014 года — магазин заработал 27 тысяч долларов с помощью стандартного класса доставки. Интересно, откуда были клиенты, сделавшие эти заказы? Чтобы узнать, надо объединить данные о заказах с данными о клиентах.</p>
</div>
<div id="объединяем-несколько-датафреймов" class="section level2">
<h2>Объединяем несколько датафреймов</h2>
<p>До сих пор мы смотрели только на таблицу с заказами. Но ведь у нас есть еще данные о клиентах интернет-магазина. Загрузим их в переменную customers и посмотрим, что они собой представляют:</p>
<pre><code>&gt; customers = pd.read_csv(&#39;customers.csv&#39;, index=&#39;id&#39;)
&gt; customers.head()
                     name    segment           state             city
id                                                                   
CG-12520      Claire Gute   Consumer        Kentucky        Henderson
DV-13045  Darrin Van Huff  Corporate      California      Los Angeles
SO-20335   Sean O&#39;Donnell   Consumer         Florida  Fort Lauderdale
BH-11710  Brosina Hoffman   Consumer      California      Los Angeles
AA-10480     Andrew Allen   Consumer  North Carolina          Concord</code></pre>
<p>Мы знаем тип клиента, место его проживания, его имя и имя контактного лица. У каждого клиента есть уникальный номер id. Этот же номер лежит в колонке customer_id таблицы orders. Значит мы можем найти, какие заказы сделал каждый клиент. Например, посмотрим, заказы пользователя CG-12520:</p>
<pre><code>&gt; cust_filter = &#39;CG-12520&#39;
&gt; orders.query(&#39;customer_id == @cust_filter&#39;)
                order_date ship_mode customer_id   sales
id                                                          
CA-2016-152156  2016-11-08    Second    CG-12520  993.90
CA-2017-164098  2017-01-26     First    CG-12520   18.16
US-2015-123918  2015-10-15  Same Day    CG-12520  136.72</code></pre>
<p>Вернемся к задаче из предыдущего раздела: узнать, что за клиенты, которые сделали 18 марта заказы со стандартной доставкой. Для этого объединим таблицы с клиентами и заказами. Датафреймы объединяют с помощью методов .concat(), .merge() и .join(). Все они делают одно и то же, но отличаются синтаксисом — на практике достаточно уметь пользоваться одним из них.
Покажу на примере .merge():</p>
<pre><code>&gt; new_df = pd.merge(orders, customers, how=&#39;inner&#39;, left_on=&#39;customer_id&#39;, right_index=True)
&gt; new_df.columns
Index([&#39;order_date&#39;, &#39;ship_mode&#39;, &#39;customer_id&#39;, &#39;sales&#39;, &#39;name&#39;, &#39;segment&#39;,
       &#39;state&#39;, &#39;city&#39;],
      dtype=&#39;object&#39;)
      ```
В .merge() я сначала указал названия датафреймов, которые хочу объединить. Затем уточнил, как именно их объединить и какие колонки использовать в качестве ключа.
Ключ — это колонка, связывающая оба датафрейма. В нашем случае — номер клиента. В таблице с заказами он в колонке customer_id, а таблице с клиентами — в индексе. Поэтому в команде мы пишем: left_on=&#39;customer_id&#39;, right_index=True.

## Решаем задачу

Закрепим полученный материал, решив задачу. Найдем 5 городов, принесших самую большую выручку в 2016 году.
Для начала отфильтруем заказы из 2016 года:</code></pre>
<blockquote>
<p>orders_2016 = orders.query(“order_date &gt;= ‘2016-01-01’ &amp; order_date &lt;= ‘2016-12-31’”)
orders_2016.head()
order_date ship_mode customer_id sales
id<br />
100041 2016-11-20 Standard BF-10975 328.5
100083 2016-11-24 Standard CD-11980 24.8
100153 2016-12-13 Standard KH-16630 63.9
100244 2016-09-20 Standard GM-14695 475.7
100300 2016-06-24 Second MJ-17740 4,823.1</p>
</blockquote>
<pre><code>Город — это атрибут пользователей, а не заказов. Добавим информацию о пользователях:</code></pre>
<blockquote>
<p>with_customers_2016 = pd.merge(customers, orders_2016, how=‘inner’, left_index=True, right_on=‘customer_id’)
Cруппируем получившийся датафрейм по городам и посчитаем выручку:
grouped_2016 = with_customers_2016.groupby(‘city’)[‘sales’].sum()
grouped_2016.head()
city
Akron 1,763.0
Albuquerque 692.9
Amarillo 197.2
Arlington 5,672.1
Arlington Heights 14.1
Name: sales, dtype: float64</p>
</blockquote>
<pre><code>Отсортируем по убыванию продаж и оставим топ-5:</code></pre>
<blockquote>
<p>top5 = grouped_2016.sort_values(ascending=False).head(5)
print(top5)
city
New York City 53,094.1
Philadelphia 39,895.5
Seattle 33,955.5
Los Angeles 33,611.1
San Francisco 27,990.0
Name: sales, dtype: float64
```
Готово!</p>
</blockquote>
</div>

            </div>
        </article>

        <hr />

        <div class="post-info">
  				<p>
  					<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7" y2="7"></line></svg><span class="tag"><a href="/tags/pandas">pandas</a></span>
  				</p>
  		</div>
    </main>

            </div>

            
                <footer class="footer">
    <div class="footer__inner">
        <div class="footer__content">
            <span>&copy; 2020</span>
            
            <span></span>
            <span> <a href="/posts/index.xml" target="_blank" title="rss"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></a></span>
        </div>
    </div>
    <div class="footer__inner">
        <div class="footer__content">
            <span>Powered by <a href="http://gohugo.io">Hugo</a></span>
            <span>Made with &#10084; by <a href="https://github.com/rhazdon">Djordje Atlialp</a></span>
        </div>
    </div>
</footer>

            
        </div>

        




<script type="text/javascript" src="/bundle.min.2d5469329143160ae2456a69c3c76dc2d0a3b212b46afe291a51bd68650ed6f8697e001dab54f1c272c77ce08092a8c55e5bb4314e0ee334aab4b927ec896638.js" integrity="sha512-LVRpMpFDFgriRWppw8dtwtCjshK0av4pGlG9aGUO1vhpfgAdq1TxwnLHfOCAkqjFXlu0MU4O4zSqtLkn7IlmOA=="></script>



    </body>
</html>
