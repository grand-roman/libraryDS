---
title: Обработка исключений Python — блок Try/Except, блок Finally
author: Кристина Ярлыкова
date: '2020-03-24'
slug: python-try-except-finally
categories:
  - Python
tags:
  - try/except
comments: no
images: ~
---


## 1.Обработка исключений Python

 В этом материале речь пойдет о блоках `try/except`, `finally` и `raise`. Вместе с тем будет рассмотрено, как создавать собственные исключения в Python.

##2. Обработка исключений в Python

Рассмотрим разные типы исключений в Python, которые появляются при срабатывании исключения в коде Python.

## 3. Блоки try/except

Если код может привести к исключению, его лучше заключить в блок `try`. Рассмотрим на примере.


```python
try:
    for i in range(3):
        print(3/i)
except:
    print("Деление на 0")
    print("Исключение было обработано")
```

```
## Деление на 0
## Исключение было обработано
```

Программа вывела сообщение, потому что было обработано исключение.

Следом идет блок `except`. Если не определить тип исключения, то он будет перехватывать любые. Другими словами, это общий обработчик исключений.

Если код в блоке `try` приводит к исключению, интерпретатор ищет блок `except`, который указан следом. Оставшаяся часть кода в `try` исполнена не будет.

Исключения Python особенно полезны, если программа работает с вводом пользователя, ведь никогда нельзя знать, что он может ввести.

### a. Несколько except в Python

У одного блока try может быть несколько блоков `except`. Рассмотрим примеры с несколькими вариантами обработки.


```python
a, b = 1, 0
try:
    print(a/b)
    print("Это не будет напечатано")
    print('10'+10)
except TypeError:
    print("Вы сложили значения несовместимых типов")
except ZeroDivisionError:
    print("Деление на 0")
```

```
## Деление на 0
```
Когда интерпретатор обнаруживает исключение, он проверяет блоки `except` соответствующего блока `try`. В них может быть объявлено, какие типы исключений они обрабатывают. Если интерпретатор находит соответствующее исключение, он исполняет этот блок `except`.

В первом примере первая инструкция приводит к `ZeroDivisionError`. Эта ошибка обрабатывается в блоке `except`, но инструкции в try после первой не исполняются. Так происходит из-за того, что после первого исключения дальнейшие инструкции просто пропускаются. И если подходящий или общий блоки `except` не удается найти, исключение не обрабатывается. В таком случае оставшаяся часть программы не будет запущена. Но если обработать исключение, то код после блоков `except` и `finally` исполнится. Попробуем.

```python
a, b = 1, 0
try:
   print(a/b)
except:
   print("Вы не можете разделить на 0")
```

```
## Вы не можете разделить на 0
```

```python
print("Будет ли это напечатано?")
```

```
## Будет ли это напечатано?
```

Рассмотрим вывод:

`Вы не можете разделить на 0`
`Будет ли это напечатано?`

### b. Несколько исключений в одном except

Можно использовать один блок ``except` для обработки нескольких исключений. Для этого используются скобки. Без них интерпретатор вернет синтаксическую ошибку.


```python
try:
    print('10'+10)
    print(1/0)
except (TypeError,ZeroDivisionError):
    print("Неверный ввод")
```

```
## Неверный ввод
```

## 4. Блок finally в Python

После последнего блока `except` можно добавить блок `finally`. Он исполняет инструкции при любых условиях.

```
try:
    print(1/0)
except ValueError:
    print("Это ошибка значения")
finally:
    print("Это будет напечатано в любом случае.")
```
`## Это будет напечатано в любом случае.`
```
Traceback (most recent call last):  
  File “<pyshell#113>”, line 2, in <module>  
    print(1/0)
ZeroDivisionError: division by zero
```
Стоит обратить внимание, что сообщение с ошибкой выводится после исполнения блока `finally`. Почему же тогда просто не использовать `print`? Но как видно по последнему примеру, блок `finally` запускается даже в том случае, если перехватить исключение не удается.

А что будет, если исключение перехватывается в `except`?

```
try:
    print(1/0)
except ZeroDivisionError:
    print(2/0)
finally:
    print("Ничего не происходит")
```
```
Ничего не происходит

Traceback (most recent call last):
  File "<pyshell#1>", line 2, in <module>
    print(1/0)
ZeroDivisionError: division by zero

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "<pyshell#1>", line 4, in <module>
    print(2/0)
ZeroDivisionError: division by zero
```

Как видите, код в блоке `finally` исполняется в любом случае.

## 5. Ключевое слово raise в Python

Иногда нужно будет разбираться с проблемами с помощью вызова исключения. Обычная инструкция `print` тут не сработает.

`raise ZeroDivisionError`

```
Traceback (most recent call last):
  File "<pyshell#2>", line 1, in <module>
    raise ZeroDivisionError
ZeroDivisionError
```
Разберемся на примере операции деления:

```
a,b=int(input()),int(input())  # вводим 1 затем 0
if b==0:
    raise ZeroDivisionError
```
```
Traceback (most recent call last):
  File "<pyshell#2>", line 3, in <module>
    raise ZeroDivisionError
ZeroDivisionError
```
Здесь ввод пользователя в переменные `a` и `b` конвертируется в целые числа. Затем проверяется, равна ли `b` нулю. Если да, то вызывается `ZeroDivisionError`.

Что будет, если то же самое добавить в блоки `try-except`? Добавим следующее в код. Если запустить его, ввести `1` и `0`, будет следующий вывод:

```
a,b=int(input()),int(input())
try:
    if b==0:
        raise ZeroDivisionError
except:
   print("Деление на 0")
print("Будет ли это напечатано?")
```
Рассмотрим еще несколько примеров, прежде чем двигаться дальше:
`raise KeyError`
```
Traceback (most recent call last):
  File “<pyshell#180>”, line 1, in <module>
    raise KeyError
KeyError
```

